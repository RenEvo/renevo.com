<p></p>  <p>One of the stresses of working in software development is getting the applications built on a regular basis.&#xA0; Generally builds are done on a Sr. Developers workstation, then sent off to testing attached to the bug software, via email, or a link to a shared resource.</p>  <p>Getting automated builds up an running is a tricky thing, and with some complex projects requires a lot of scripting and knowledge of the internal software as well as some licensing issues with the software.</p>  <p>When requested to get &quot;Automated Nightly Builds&quot; working by the VP of Software Development in a recent meeting, I looked at our 10+ software products and just shuddered. Below is a list of software that we use.</p>  <p><a href="http://msdn2.microsoft.com/en-us/vstudio/default.aspx" target="_blank">Microsoft Visual Studio</a> 2003, 2005, and Visual Basic 6 for Code     <br /><a href="http://www.seapine.com/surroundscm.html" target="_blank">Seapine Surround Source Control Management</a> (SCM)     <br /><a href="http://www.seapine.com/ttpro.html" target="_blank">Seapine Test Track Pro</a> for Bug Tracking     <br /><a href="http://www.macrovision.com/products/installation/installshield.htm" target="_blank">Install Shield 12</a> for some of our software installation media     <br /><a href="http://www.win-rar.com/" target="_blank">WinRar</a> for patch packaging     <br /><a href="http://msdn2.microsoft.com/en-us/library/0k6kkbsd.aspx" target="_blank">MSBuild</a> from the .Net 2.0 Framework for OneClick installation generation and Satellite Resource File Compilations</p>  <p>As you can see, building integration between a lot of those products and kicking off event driven automated builds is going to be tricky.&#xA0; Although I have recently downloaded and implemented <a href="http://confluence.public.thoughtworks.org/display/CCNET/Welcome+to+CruiseControl.NET" target="_blank">Cruise Control .Net</a> for remote builds of one of our products, putting together the rest are going to be tricky. </p>  <p>Let me explain the game plan that I will be attempting, and I will blog my progress with the pitfalls of the system.</p>  <p><strong>Pulling from source control</strong></p>  <p>The hardest part of this is going to be getting the code out of source control, granted it is just a quick pull of the files into a directory, but managing which branch to work out of is the trickiest.&#xA0; Surround SCM allows you to do multiple branches of source code and we have implemented an implementation that allows our Junior developers to work on sub-branches, while I, as the only Senior developer at the moment, work in the main branch of the code.&#xA0; On a daily basis, or as needed, I review the code and promote it from the Junior level sub-branch, retrieve the code, then check for a stable build.&#xA0; This is obviously a process that can not be automated.&#xA0; So firstly, I am going to have to create two builds, one for the in-testing code, which would be from the sub-branch, and a second for release code, which is pulled from the main branch.</p>  <p><strong>Compiling the code</strong></p>  <p>With the third party tools that we are currently using, some unique licensing has to be in place in order to compile the applications.&#xA0; Although using command line compilers and not running out of the IDE might be able to just imbed current licensing, I am pretty sure that the licensing scheme of some of our assemblies will prove to require additional licensing.&#xA0; A good example of this is the activation based Red Gate tools that we are using.</p>  <p><strong>Building the applications</strong></p>  <p>We have three different scenarios with the products that we produce. The first being the easiest, is a completely self contained application, all of the source code is stand alone, and requires no other shared projects.&#xA0; The second scenario are web sites, these are going to require that we only pull the releasable files, such as ascx, aspx, asax, and binaries for instance. And the third is the most difficult, this one is our framework based applications.&#xA0; We have a shared framework based on the Composite UI Application Block from Microsoft so that we can accommodate modular based application design.&#xA0; When we want to add a new product, we simply create a new set of modules that load into the application framework.&#xA0; Then we can distribute them and only turn them on if the client has licensing for them.&#xA0; This is also the way that we are trying to move all of our applications into, our &quot;OneSource&quot; for applications, which also happens to be the name of our framework.</p>  <p><strong>Creating the OneClick Installs</strong></p>  <p>With our newest framework applications, we are using the OneClick technology from Microsoft that is built into .Net 2.0.&#xA0; This is an outstanding way to get updates out to our customers without calling or emailing them to update their software. The largest problem with OneClick installations though is that they are statically bound to an install location so if you configure the OneClick to install from <a href="http://www.domain.com">http://www.domain.com</a> then you have to have to deploy it FROM that location.&#xA0; This extra step is going to require that we additionally setup multiple staging environments for the OneClick installations.&#xA0; The first staging area will be our internal developer only install.&#xA0; This is used primarily for internal review of the latest software by the VP, Analysts, as well as Technical writers.&#xA0; Secondly, we will want to create a Beta, or Pre-Release tab, this will need to be publicly accessible and could potentially be given to customers, the CEO, Project Managers, and the Help Desk for training on new features, as well as approval and additional QA.&#xA0; The final staging that will need to be built is the Release staging.&#xA0; This will basically be the released version of the software for everyone to install and will be made available via a public domain.</p>  <p><strong>Building the Install Media</strong></p>  <p>This one is by far one of the trickiest ones.&#xA0; Due to the fact that files could be added or removed from the installations, knowing what to add, as well as adding it to the installer in the correct place before compiling, is going to prove to be extremely tricky.&#xA0; To be honest, this is the area that I am least knowledgeable about how to do, and will be doing a lot of research on it when I get there.</p>  <p><strong>Building the Patch Media</strong></p>  <p>This one is pretty easy, basically we take the build directories for the software, add it to an SFX via a huge command line to WinRar.exe and it creates a nice little patch for us.&#xA0; I could probably take it one step further generating a CRC32 compare list and only adding changed files, but this is a nice way to &quot;Magic Zip&quot; update previous installations that might not be completely up to date.</p>  <p><strong>Notifications</strong></p>  <p>Of coarse this entire process needs to be logged and sent to the right people if something goes wrong. Luckily this is where Cruise Control .Net is going to come into play, as it will log the entire process (by redirecting the standard output when it calls all of the executables) and save them to XML in the working directories of the builds. Myself and the VP also run the Cruise Control client application in the Tray that displays the status of each build, last build time, and any additional messages.&#xA0; When a build is finished, we get a little popup in the bottom right hand of the screen letting us know if it was successful or not.&#xA0; Obviously this is ok for working hour builds, but I would prefer to have more information.&#xA0; So I will be setting up SMS alerting and Email logs to the end of the build.</p>  <p>&#xA0;</p>  <p>Basically that's it... not much work, if you like this sort of thing, but unfortunately I still have to maintain the constant stream of new features, updates, and bug fixes to the current software.</p>  <p>I will keep you up to date.</p><img src="http://renevo.com/aggbug.aspx?PostID=1533" width="1" height="1">